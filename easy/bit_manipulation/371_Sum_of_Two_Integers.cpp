//
// Created by ranpeng on 2020/4/28.
//

#include "common.h"

class Solution {
public:

    /*
    两个数的加法分为两步，对应位相加和进位。
    对应位相加就可以使用异或（xor）操作，计算进位就可以使用与（and）操作
    例子 759+674
    1. 如果不考虑进位，可以得到 323
    2. 如果只考虑进位，可以得到 1110
    3. 把上面两个数字假期 323+1110=1433 就是最终结果了
     在二进制下来看，不考虑进位的加，0+0=0，0+1=1, 1+0=1，1+1=0，这就是异或的运算规则，如果只考虑进位的加 0+0=0, 0+1=0, 1+0=0,
     1+1=1，而这其实这就是'与'的运算，而第三步在将两者相加时，再递归调用这个算法，终止条件是当进位为0时，直接返回第一步的结果。
     LeetCode自己的编译器比较strict，不能对负数进行左移，就是说最高位符号位必须要为0，才能左移。
     那么在a和b相 '与' 之后，再'与'上一个最高位为0，其余位都为1的数 0x7fffffff，这样可以强制将最高位清零，然后再进行左移
     */
    int getSum(int a, int b) {
        while (b != 0) {
            int carry = (a & b & 0x7fffffff) << 1; // 进位
            a ^= b; // 不考虑进位加
            b = carry;
        }
        return a;
    }
};

int main() {
    std::cout << Solution().getSum(1, 2) << std::endl;
    return 0;
}